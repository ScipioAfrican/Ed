-m64 или -m32
64-х битная или 32-х битная программа.

-march=x86-64, core2, corei7, corei5
Оптимизация кода под конкретную архитектуру. Очень важно для оптимизации.

-O3
Максимальная оптимизация по скорости. Возможно это приводит к некоторому увеличению размера программы.
Вряд ли кто-нибудь заметит увеличение размера программы на пять-десять килобайт.
В то же время быстродействия программам всегда не хватает. Ещё более агрессивный флаг Ofast

-mfpmath=sse
По умолчанию большинство GCC компиляторов для x86 в 32-х битном режиме используют x87 модель вычислений с плавающей точкой.
Только если GCC конфигурация содержит “--with-mfpmath=sse” - компилятор будет использовать SSE модель по умолчанию.
Во всех остальных случаях лучше добавлять опцию “-mfpmath=sse” к сборке в 32 битном режиме.
В 64 битном режиме (по сравнению с 32 битным) количество доступных регистров общего пользования увеличивается с 6 до 14,
XMM регистров с 8 до 16. Также все 64 битные архитектуры поддерживают SSE2 расширение,
поэтому в 64 битном режиме не надо добавлять опцию “-mfpmath=sse”.

-pipe
Компилятор GCC обрабатывает программу за несколько проходов, помещая промежуточные
результаты компиляции во временные файлы. Процесс компиляцию можно ускорить, если
воспользоваться опцией -pipe. При включении этой опции, различные этапы компиляции
начинают "общаться" между собой не через временные файлы, а через каналы обмена (pipes).
Этот флаг не влияет на генерируемый код, но ускоряет процесс компиляции. 
Он сообщает компилятору, чтобы тот использовал конвейер (pipe) вместо временных файлов в течение разных стадий компиляции,
которые используют большее количество памяти. На системах с небольшим количеством памяти, GCC может завершить свою работу.
В этих случаях, не используйте этот флаг.

-fomit-frame-pointer
Не использовать указатель на стековый фрейм. Компилятор будет адресовать переменные в стеке с помощью регистра ESP
а регистр EBP "высвобождается" для использования в качестве регистра общего назначения.
Это очень часто используемый флаг, предназначенный для того, чтобы уменьшить размер генерируемого кода.
Он включается на всех уровнях с префиксом -O (исключая -O0) на тех архитектурах, где это не затрудняет отладку
(таких как x86-64), но его, возможно, необходимо активировать. В этом случае добавьте его к флагам.
Хотя руководство по GCC не указывает все архитектуры, но он включается с использованием параметра -O.
Также нужно явно активировать -fomit-frame-pointer для x86-32, если GCC версии ниже 4.6, либо при использовании
-Os на x86 -32 с любой версией GCC.
Однако, использование -fomit-frame-pointer может сделать отладку сложной, или даже невозможной.
Поэтому, в то время как использование этого флага может помочь, оно также затрудняет отладку; трассировка стека,
в частности, будет бесполезна. Если не планируется отлаживать программы и нет других переменные CFLAGS,
связанные с отладкой, такие как -ggdb, то попробуйте использовать -fomit-frame-pointer.

-flto
Межмодульные оптимизации. “-flto” делает возможным удаление неиспользуемых функций. Функция может стать таковой, 
если в конкретной конфигурации приложения она не вызывается или была полностью и во всех местах вызова подставлена в код. 
Для того, чтобы удалить неиспользуемые функции без “-flto” можно воспользоваться “-ffunction-sections -Wl,--gc-sections”.
Данная техника дает хороший результат, если в приложении используются внутренние статические библиотеки.

-malign-double
Контролирует, выравнивает ли GCC double, long double и long long переменные на двусловной границе или однословной границе.
Выравнивание double-переменных на двусловной границе создает код, который выполняется на Pentium-процессорах несколько быстрее,
расходуя больше памяти.

-fexceptions
Включить поддержку механизма исключительных ситуаций языка C++
Если вы используете механизм исключений (exceptions) языка C++, то при компиляции
должна быть включена соответствующая опция.

-ffast-math
АГРЕССИВНЫЙ ФЛАГ. Включает более высокий уровень оптимизаций и более агрессивные оптимизации для
арифметических вычислений (например, вещественную реассоциацию).
Эта опция позволяет GCC нарушать некоторые ANSI или IEEE-правила и/или спецификации в интересах оптимизации кода
по скорости выполнения. Например, это позволяет компилятору предполагать, что параметры к функции sqrt 
неотрицательные числа, и что значения не с плавающей запятой являются NaNs.

-Ofast
АГРЕССИВНЫЙ ФЛАГ. Аналогичен "-O3 -ffast-math" - включает более высокий уровень оптимизаций
и более агрессивные оптимизации для арифметических вычислений (например, вещественную реассоциацию).

-funroll-loops
АГРЕССИВНЫЙ ФЛАГ. Включает развертывание циклов. Это осуществляется для циклов число итераций которых может быть определено
во время компиляции или во время выполнения.

-funroll-all-loops
АГРЕССИВНЫЙ ФЛАГ. Выполняется оптимизация развертыванием циклов. Развертывает все циклы, и обычно программы скомпилированные 
с этой опцией медленнее запускаются.

-fforce-mem
АГРЕССИВНЫЙ ФЛАГ. Принуждает копировать операнды, хранящиеся в памяти, в регистры перед выполнением арифметических операций над ними.
В результате получается лучший код, в котором все ссылки на ячейки памяти потенциально общие подвыражения.
Когда они не являются общими подвыражениями, то комбинации команд должны устранить отдельную загрузку регистра.

-fforce-addr
АГРЕССИВНЫЙ ФЛАГ. Вынуждает копировать постоянные адреса памяти в регистры перед выполением арифметических операций над ними.
В результате может создаваться более хороший код, так же как и при -fforce-mem.
